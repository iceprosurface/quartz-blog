---
title: 原型方法，对象方法和类方法的个人整理
date: 2016-03-02 14:54:51 +0800
comments: true
tags: javascript
permalink: /2016/03/02/2016/2016-03-02-js-iife/
updated: 2024-05-13T10:32:03+08:00
---

> 本文受[阮一峰javascript模块化编程](http://www.ruanyifeng.com/blog/2012/10/javascript_module.html) 启发
>
> 本文受[js中使用使用原型（prototype）定义方法的好处](http://www.cnblogs.com/yunfour/p/3946444.html) 启发
> 
> 本文受[深入理解javascript系列（4）：立即调用的函数表达式](http://www.cnblogs.com/TomXu/archive/2011/12/31/2289423.html) 启发
>

函数的基本声明方法
=================

首先记录一下常见的几种函数声明方法

 + 函数声明 function fname(){}
 + 函数表达式声明 var fname = function(){}
 + 匿名表达式 function(){}

关于立即执行函数的解析
---------------------

<!-- more -->


 在js中，使用一个函数通常使用fname();的方式来执行函数表达式,但是假如我们用的不是函数声明而是表达式声明的话,我们会发现有趣的一点：基于这一点我们可以在声明完函数后立即使用函数，这种函数被称为立即执行函数比如：

 你会发现所谓的fname()中的fname就是function的引用，那么我们为什么不直接在后面加上()让他执行呢？基于这一点我们可以在声明完函数后立即使用函数，这种函数被称为立即执行函数比如：

 > + (function(){})();
 > + (function(){}());

 这两种形式通过()操作让解释器认为这个function是一个函数表达式，也就可以声明一个立即执行函数，同样的只要是对函数表达式声明进行操作的运算符都可以触发这个效果，所以同理~/！/-/+也同样可以触发该项操作比如

 > + -function(){}();
 > + +function(){}();
 > + ~function(){}();
 > + !function(){}();

 如果你不嫌麻烦完全可以用上面那些方法声明一个表达式，但是显然这不是阅读良好的程序，因为你必须吧框框拉倒最后去看看有没有一个()

 所以在诸如jquery等常见的类库都是用了()来执行，目的是防止阅读障碍。这个解析主要是后面整理的前置知识。

对象方法
================

 对象方法可以这么理解：如果类生成一个实例，那么该实例就能使用该方法

 比如下面这个例子：

```js
 var module1 = new Object({

　　　　_count : 0,

　　　　m1 : function (){
　　　　　　//...
　　　　},

　　　　m2 : function (){
　　　　　　//...
　　　　}

　　});
module1.m1();
module1.m2();

```

  上面的函数m1()和m2()，都封装在module1对象里。使用的时候，就是调用这个对象的属性。

类方法
================

类方法简单的讲：不需要通过生成实例就可以使用的方法

比如下面这个例子：

```js
function fname(name){
	// private
	var className = "fname";
	// public
	this.name = name;
	this.hello = function(){
	}
}
// 类方法
fname.Run = function(){

}
// 类方法的使用
fname.Run();
fname.hello();
```

上面的函数Run()和hello()，都封装在fname类里。使用的时候，不需要生成一个实例就可以直接使用。

原型方法
===========

原型方法简单的将就是：主要是用来对已有的对象进行扩展，例如Array数组没有什么方法，你可以为其增加原型方法，那么创建的数组就拥有了该方法。

```js
fname.prototype.sayName=function(){
	console.log(this.name);
};
var fname1=new fname("fname1");
fname1.sayName();
```

假设说我已经通过一个类生成了一堆对象，那么现在我需要对某个方法进行补充那么就可以通过这个原型方法为这些方法补充原型方法。

除此以外，原型方法本质上是一种指针，指向的是对应的prototype对象，不需要对每一个方法扩展内存，所以许多前端工程师都推荐使用原型方法来命名以减少内存消耗。
